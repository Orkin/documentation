---
last_modified_on: "2022-12-27"
$schema: "/.meta/.schemas/guides.json"
title: "Use AWS IAM roles with Qovery"
description: "Give AWS IAM permissions to your application/container/job with Qovery"
author_github: https://github.com/deimosfr
tags: ["type: tutorial", "technology: qovery"]
hide_pagination: true
---
import Jump from '@site/src/components/Jump';
import Alert from '@site/src/components/Alert';
import Assumptions from '@site/src/components/Assumptions';

AWS IAM (Identity & Access Management) service allows AWS services to interact with each other by using roles. Those roles can easily be used to give permissions to your Qovery application, container or job.

It is a secure way to give your application permissions without having to manage credentials. More than that, it rotates the token automatically.

This tutorial will show you how to add AWS IAM roles to your Qovery application, container or job.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/guides/tutorial/use-aws-iam-roles-with-qovery.md.erb
-->

## Application requiering S3 permissions

In this first step, we will create a simple application that needs AWS permissions to access s3 buckets.

### Create an application

We are going to will create a simple container, but you can use an existing one if you want (or an application or job). 

<Alert type="info">

You do not have to deploy it now, just create one container this way.

</Alert>

Here is a simple Debian container example:

<p Valign="center">
  <img src="/img/aws-iam-assume-role/debian_app.png" alt="debian app" />
</p>

Set only 1 instance and 128MB of memory is enough for this example. Then continue until you have the `Create` button, there is nothing more to setup.

### Get Kubernetes namespace name

Then in this container `Variables`, search for the variable called `QOVERY_KUBERNETES_NAMESPACE_NAME` and copy its value somewhere.

<p Valign="center">
  <img src="/img/aws-iam-assume-role/debian_namespace.png" alt="debian app" />
</p>

It is the Kubernetes namespace name where the container is located.

## Configure OIDC provider

<Alert type="info">

This step should be done only once per cluster

</Alert>

### Get your Cluster OIDC provider URL

On your AWS console, go to your EKS cluster and `Overview` section. Copy the `OpenID Connect provider URL`:

<p Valign="center">
  <img src="/img/aws-iam-assume-role/eks_oidc.png" alt="EKS OIDC" />
</p>

### Create an Identity provider

On your AWS console, go to `IAM` service, then `Identity providers` section, and `Add provider` button:

1. Select the `OpenID Connect` provider type
2. Paste the `OpenID Connect provider URL` previously copied to `Provider URL`
3. Click on `Get thumbprint` button, once done the button will change to `Edit URL`
4. Add `sts.amazonaws.com` as `Audience`
5. Click on `Add provider` button

<p Valign="center">
  <img src="/img/aws-iam-assume-role/oidc_connect.png" alt="OIDC Connect" />
</p>

## Configure AWS IAM roles

### Create a role

Now we can create a role. In the `IAM` service, go to `Roles` section, and click on `Create role` button.

You have to select the Trusted entity type. For this tutorial, we are going to use the `Web identity` type.

Set the `Identity provider` to the one you just created, and the `Audience` to `sts.amazonaws.com`. Then click on the `Next` button.

<p Valign="center">
  <img src="/img/aws-iam-assume-role/role_create_step1.png" alt="Role create step 1" />
</p>

### Role permissions

Select the policy of your choice. For this example, the policy `AmazonS3ReadOnlyAccess` will be used to list S3 buckets. Then click on the `Next` button.

To finish, set the role name and description of your choice and click on `Create role` button.

### Configure trusted entities

Once created, select your freshly created role, go to the `Trust relationships` tab, and click on `Edit trust policy` button.

<p Valign="center">
  <img src="/img/aws-iam-assume-role/role_trusted_entities_default.png" alt="role trusted default" />
</p>

Update the policy line regarding the `OIDC` condition from:
```
"oidc.eks.eu-west-3.amazonaws.com/id/xxxxxxx:aud": "sts.amazonaws.com"
```

to:

```
"oidc.eks.eu-west-3.amazonaws.com/id/xxxxxxx:sub": "system:serviceaccount:kubernetes_namespace:service_account_name"
```

Replace:
* `kubernetes_namespace`: with the namespace name ([previously copied in step 1](#get-kubernetes-namespace-name))
* `service_account_name`: define a service account name which will be re-use later (ex: `my-s3-role`)

Once done, click on the `Update policy` button.

Last element to copy and save somewhere: the role `ARN`.

## Create a service account

<Alert type="info">

If you already have an existing service account on your Kubernetes cluster and want to use it, you can skip this step.

</Alert>

<Alert type="warning">

Kubernetes reminder: **a deployed service account in a Kubernetes namespace, becomes available by all applications in the same namespace.**

</Alert>

This step will help you on deploying a service account on your Kubernetes cluster. In case you want to do it manually on the cluster with `kubectl`, you just have to push a service account like:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
 name: $SERVICE_ACCOUNT_NAME
 namespace: $QOVERY_KUBERNETES_NAMESPACE_NAME
 annotations:
   eks.amazonaws.com/role-arn: $AWS_ROLE_ARN
```

### Kubernetes authentication

On AWS, there are [several ways to authenticate to Kubernetes](https://docs.aws.amazon.com/eks/latest/userguide/cluster-auth.html). To make it simple, we are going to use a dedicated IAM user, but you can select the best method for your need.

From your AWS Console, create an IAM user account, get `Access key ID` and `Secret access key` and save them somewhere.

Qovery helps [IAM users to get quick access to the Kubernetes cluster](/guides/tutorial/how-to-connect-to-your-eks-cluster-with-kubectl/#add-your-iam-user-to-the-admin-group). Simply add this user to the `Admins` group.

### Create a Lifecycle job

In the same environment than your application, create a `Lifecycle job` which will be used to deploy a service account on the Kubernetes cluster:

<p Valign="center">
  <img src="/img/aws-iam-assume-role/lifecycle_step1.png" alt="Lifecycle creation" />
</p>

Here a container `qoveryrd/create-sa:1.0` available on [DockerHub](https://hub.docker.com/r/qoveryrd/create-sa) made by Qovery is used, but you can fork [this repository](https://github.com/Qovery/create_service_account) and update to your needs if you prefer.

Click on the `Continue` button and select the `Start` event because we want to deploy the service account at the environment start. Then click on the `Continue` button, set the resources (128Mb is enough) and click on the `Continue` button.

Then add the following environment variables to the `job` scope:
* `KUBERNETES_VERSION`: the version of your Kubernetes cluster which will be used to download kubectl (ex: 1.23.0)
* `SERVICE_ACCOUNT_NAME`: the name of the service account in Kubernetes (the same name [you have declared](#configure-trusted-entities) for the role in the `Trusted entities` policy section)
* `AWS_ROLE_ARN`: the AWS ARN role you have just created
* `AWS_ACCESS_KEY_ID`: the AWS access key ID of the IAM user you have created (if you decided to use this authentication method)
* `AWS_SECRET_ACCESS_KEY`: the AWS secret access key of the IAM user you have created (if you decided to use this authentication method)

<p Valign="center">
  <img src="/img/aws-iam-assume-role/lifecycle_step2.png" alt="Lifecycle creation" />
</p>

Then `Create` the `Lifecycle job`. Go into the `Variables` tab and create a `Variable Alias` on `QOVERY_CLOUD_PROVIDER_REGION`, name it `AWS_DEFAULT_REGION` and scope it to the `job`.

<p Valign="center">
  <img src="/img/aws-iam-assume-role/lifecycle_step3.png" alt="Lifecycle creation" />
</p>

You can now run your job by clicking on the `Deploy now` button. You should see the following output in your job logs:

```
-> Ensuring required environment variables are present
-> Downloading kubectl version 1.23.0
-> Generated service account:
apiVersion: v1
kind: ServiceAccount
metadata:
 name: my-s3-role
 namespace: xxxxxx
 annotations:
   eks.amazonaws.com/role-arn: arn:aws:iam::xxxxxx:role/my-s3-role
-> Getting kubeconfig
Added new context arn:aws:eks:region:id:cluster/cluster-name to /root/.kube/config
-> Deploying service account
serviceaccount/aws-permissions created
```

## Set application service account

### Set service account

The final step is to set this service account (pointing to the AWS role) to your application. Go into your application `Advanced settings` and set the `Service account` to the one you have just created:

<p Valign="center">
  <img src="/img/aws-iam-assume-role/debian_sa.png" alt="Lifecycle creation" />
</p>

Deploy your application with the `Deploy now` button.

At this stage, the job should have been executed and the service account should be deployed on your Kubernetes cluster, and the Debian container, running.

### Validate access

To validate the AWS role has correctly been deployed, we can connect to the pod, and see if we have the AWS token. We will use the Qovery CLI to connect to our pod:

```bash
$ qovery shell
Qovery: Select organization
Organization:
✔ Qovery
Qovery: Select project
Project:
✔ AWS roles tutorial
Qovery: Select environment
Environment:
✔ aws-role
Qovery: Select service
Services:
✔ debian
```

Now we are connected to the pod, we can check the AWS token:

```bash
$ env | grep AWS
AWS_DEFAULT_REGION=us-east-2
AWS_REGION=us-east-2
AWS_ROLE_ARN=arn:aws:iam::xxxxxx:role/my-s3-role
AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token
AWS_STS_REGIONAL_ENDPOINTS=regional
```

Token is here! Let's install the AWS CLI and validate the role access. We should be able to list S3 buckets:

```bash
$ apt-get update && apt-get -y install awscli
$ aws s3 ls
2022-09-23 06:56:38 aws-cloudtrail-logs-qovery
...
```

It works! We have access to S3 buckets using the AWS role.

## Conclusion

The first setup phase can be time-consuming. However, once done, applying roles to your applications is very easy and fast. You can now use roles to access any AWS service!



